"""
Business Audit and CEO Briefing Generator for AI Employee Vault
Implements Gold Tier requirement for weekly business and accounting audit
"""
from datetime import datetime, timedelta
from pathlib import Path
import json
import calendar

class BusinessAuditor:
    def __init__(self):
        self.vault_path = Path(".")
        self.revenue_targets = {}
        self.metrics = {}

    def generate_weekly_briefing(self):
        """Generate a weekly CEO briefing"""
        # Calculate the week range
        today = datetime.now()
        start_of_week = today - timedelta(days=today.weekday())
        end_of_week = start_of_week + timedelta(days=6)

        week_str = start_of_week.strftime("%Y-%m-%d")
        end_str = end_of_week.strftime("%Y-%m-%d")

        # Gather data for the briefing
        revenue_data = self._get_revenue_data(start_of_week, end_of_week)
        completed_tasks = self._get_completed_tasks(start_of_week, end_of_week)
        bottlenecks = self._identify_bottlenecks(start_of_week, end_of_week)
        suggestions = self._get_proactive_suggestions()
        upcoming_deadlines = self._get_upcoming_deadlines()

        # Create briefing content
        briefing_content = f"""# Monday Morning CEO Briefing

---
generated: {datetime.now().isoformat()}
period: {week_str} to {end_str}
---

## Executive Summary
{self._generate_executive_summary(revenue_data, completed_tasks)}

## Revenue
- **This Week**: ${revenue_data['this_week']:,.2f}
- **Month-to-Date**: ${revenue_data['month_to_date']:,.2f} ({revenue_data['percentage_of_target']}% of ${revenue_data['monthly_target']:,.2f} target)
- **Trend**: {revenue_data['trend']}

## Completed Tasks
{self._format_completed_tasks(completed_tasks)}

## Bottlenecks
{self._format_bottlenecks(bottlenecks)}

## Proactive Suggestions
{self._format_suggestions(suggestions)}

## Upcoming Deadlines
{self._format_deadlines(upcoming_deadlines)}

---
*Generated by AI Employee v0.1*
"""

        # Save the briefing
        briefings_dir = self.vault_path / "Briefings"
        briefings_dir.mkdir(exist_ok=True)

        briefing_filename = f"{week_str}_Monday_Briefing.md"
        briefing_path = briefings_dir / briefing_filename

        briefing_path.write_text(briefing_content)

        # Update dashboard with summary
        self._update_dashboard_summary(briefing_content)

        return str(briefing_path)

    def _get_revenue_data(self, start_date, end_date):
        """Get revenue data for the specified period"""
        # This would typically connect to accounting system like Odoo
        # For demo purposes, we'll use mock data
        from random import randint

        this_week = randint(1500, 3000)
        month_to_date = randint(4000, 8000)
        monthly_target = 10000
        percentage = round((month_to_date / monthly_target) * 100, 1)

        trend = "On track" if month_to_date >= (monthly_target * 0.5) else "Behind schedule"

        return {
            "this_week": this_week,
            "month_to_date": month_to_date,
            "monthly_target": monthly_target,
            "percentage_of_target": percentage,
            "trend": trend
        }

    def _get_completed_tasks(self, start_date, end_date):
        """Get completed tasks for the period"""
        done_dir = self.vault_path / "Done"
        if not done_dir.exists():
            return []

        # Find task files completed in the date range
        completed_tasks = []
        for task_file in done_dir.glob("*.md"):
            # Check if the file was modified in the target week
            # For simplicity, we'll just take the most recent ones
            content = task_file.read_text()
            completed_tasks.append({
                "filename": task_file.name,
                "content": content[:200] + "..." if len(content) > 200 else content
            })

        return completed_tasks[:10]  # Limit to 10 most recent

    def _identify_bottlenecks(self, start_date, end_date):
        """Identify bottlenecks in operations"""
        # This would analyze task completion times, etc.
        # For demo, return mock bottlenecks
        return [
            {
                "task": "Client B proposal",
                "expected_duration": "2 days",
                "actual_duration": "5 days",
                "delay": "+3 days"
            },
            {
                "task": "Software deployment",
                "expected_duration": "1 day",
                "actual_duration": "3 days",
                "delay": "+2 days"
            }
        ]

    def _get_proactive_suggestions(self):
        """Generate proactive suggestions based on patterns"""
        # Analyze recurring expenses, etc.
        suggestions = [
            {
                "category": "Cost Optimization",
                "item": "Notion subscription",
                "details": "No team activity in 45 days. Cost: $15/month.",
                "action": "[ACTION] Cancel subscription?",
                "location": "/Pending_Approval"
            },
            {
                "category": "Upcoming Deadlines",
                "item": "Project Alpha final delivery",
                "details": "Due Jan 15 (9 days)",
                "action": "Prepare handover materials"
            }
        ]
        return suggestions

    def _get_upcoming_deadlines(self):
        """Get upcoming deadlines"""
        # Would normally read from project files
        today = datetime.now()
        return [
            {
                "project": "Project Alpha",
                "deadline": (today + timedelta(days=9)).strftime("%b %d"),
                "days_left": 9
            },
            {
                "project": "Quarterly tax prep",
                "deadline": (today + timedelta(days=25)).strftime("%b %d"),
                "days_left": 25
            }
        ]

    def _generate_executive_summary(self, revenue_data, completed_tasks):
        """Generate executive summary text"""
        task_count = len(completed_tasks)
        if revenue_data['month_to_date'] >= revenue_data['monthly_target'] * 0.7:
            return f"Strong week with {task_count} tasks completed and revenue ahead of target. One bottleneck identified."
        else:
            return f"Weekly review shows {task_count} tasks completed. Revenue behind target. Multiple bottlenecks identified."

    def _format_completed_tasks(self, tasks):
        """Format completed tasks for briefing"""
        if not tasks:
            return "- No tasks completed this week\n"

        formatted = []
        for i, task in enumerate(tasks[:5]):  # Show first 5
            formatted.append(f"- [x] {task['filename'][:50]}...")  # Truncate filename
        return "\n".join(formatted)

    def _format_bottlenecks(self, bottlenecks):
        """Format bottlenecks table for briefing"""
        if not bottlenecks:
            return "No bottlenecks identified this week.\n"

        formatted = ["| Task | Expected | Actual | Delay |", "|------|----------|--------|-------|"]
        for bottleneck in bottlenecks:
            formatted.append(f"| {bottleneck['task']} | {bottleneck['expected_duration']} | {bottleneck['actual_duration']} | {bottleneck['delay']} |")
        return "\n".join(formatted)

    def _format_suggestions(self, suggestions):
        """Format proactive suggestions for briefing"""
        if not suggestions:
            return "No suggestions at this time.\n"

        formatted = []
        for suggestion in suggestions:
            formatted.append(f"\n### {suggestion['category']}")
            formatted.append(f"- **{suggestion['item']}**: {suggestion['details']}")
            if 'action' in suggestion:
                formatted.append(f"  - {suggestion['action']}")
                if 'location' in suggestion:
                    formatted.append(f"  - Move to {suggestion['location']}")
        return "\n".join(formatted)

    def _format_deadlines(self, deadlines):
        """Format upcoming deadlines for briefing"""
        if not deadlines:
            return "No upcoming deadlines.\n"

        formatted = []
        for deadline in deadlines:
            formatted.append(f"- {deadline['project']}: {deadline['deadline']} ({deadline['days_left']} days)")
        return "\n".join(formatted)

    def _update_dashboard_summary(self, briefing_content):
        """Update the dashboard with a summary"""
        dashboard_path = self.vault_path / "Dashboard.md"

        if dashboard_path.exists():
            current_content = dashboard_path.read_text()
        else:
            current_content = "# Dashboard\n\nStatus: Active\n\n"

        # Add recent activity summary
        summary_section = f"## Recent Activity\n- [{datetime.now().strftime('%Y-%m-%d %H:%M')}] Weekly briefing generated\n"

        # Find the Recent Activity section and update it, or add it if it doesn't exist
        if "## Recent Activity" in current_content:
            lines = current_content.split('\n')
            new_lines = []
            skip_block = False
            for line in lines:
                if line.startswith("## Recent Activity"):
                    new_lines.append(line)
                    new_lines.append(summary_section)
                    skip_block = True
                elif skip_block and line.startswith("##"):
                    skip_block = False
                    new_lines.append(line)
                elif not skip_block:
                    new_lines.append(line)
            updated_content = '\n'.join(new_lines)
        else:
            # Add the section at the end
            updated_content = current_content + "\n" + summary_section

        dashboard_path.write_text(updated_content)

def schedule_weekly_audit():
    """Function to schedule the weekly audit using cron or Task Scheduler"""
    # This would be implemented as a cron job or Windows Task Scheduler task
    # For demo, we'll just return the command that would be scheduled
    cron_job = "0 7 * * 1 /usr/bin/python3 /path/to/AI_Employee_Vault/scripts/run_weekly_audit.py"
    return cron_job

def run_weekly_audit():
    """Execute the weekly audit"""
    auditor = BusinessAuditor()
    briefing_path = auditor.generate_weekly_briefing()
    return briefing_path